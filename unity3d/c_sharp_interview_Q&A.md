#Unity3D面试题目 
######整理者：hauk0101
##C#语言相关部分
>1.请复制下列代码，并在编辑器中测试：


	void Start()
	{
		float a = 600.0f;
		float b = 1.0f - 80.0f / 100.0f;
		float c = a * b;
		int d = (int)c;
		Debug.Log(a);
		Debug.Log(b);
		Debug.Log(c);
		Debug.Log(d);
	}
> 变量"d"的输出结果为多少？为什么？如何解决？

作答：d的输出是119。该方式对于浮点数会做无条件舍去，失去精确度。如果希望获取float的整数部分，可以 d = Math.Floor(c)。

	Math.Round()    //四舍六入五取偶
	Math.Ceiling()  //只要有小数都加1
	Math.Floor()	//总是舍去小数

>2.数列1，1，2，3，5，8，13...第n位数是多少？用C#递归算法实现。

作答：

	private int getResult(int n)
	{
		if(n <= 0)	return 0;						//此处可根据实际情况进行容错判断，否则会出现死循环
		if(n == 1 || n == 2)	return 1;
		return getResult(n-1) + getResult(n-2);		//需要注意，当n>46时，可能会出现内存溢出问题			
	}

>3.C#中委托的用法是？

作答：1）声明一个delegate对象，它应当与你想要传递的方法具有相同的参数和返回值类型。<br>
　　　2）创建delegate对象，并“将你想要传递的函数作为参数传入”。<br>
　　　3）在要实现异步调用的地方，通过上一步创建的对象来调用方法。<br>
　　　参考文章，[地址](http://blog.csdn.net/jamestaosh/article/details/4372172)

>4.C#中Attribute和Property的区别。

作答：Attribute是Microsoft.NET Framework文件的元数据，可以用来向运行时描述你的代码，或者在程序运行的时候英雄应用程序的行为。<br>
　　　Property：属性是面向对象编程的基本概念，提供了对私有字段的访问封装，在C#中以get和set访问器方法实现对可读可写属性的操作，提供了安全和灵活的数据访问封装。

>5.C#中的序列化和反序列化是什么意思？

作答：解析对象和构建对象。通常对象都是存在于内存中的，如果我们想在远程拿到这个对象，那就要把这个对象变成一种可描述的形式进行传输，这就是序列化。反序列化就是我们拿到了一个关于对象的描述，再把它转化成内存中的对象的过程。

>6.概述反射和序列化？

作答：反射是一种在运行时动态调用代码的机制。它相比面向对象的多态的优势在于，调用方无需知道任何被调用方的信息即可调用，比如类名、方法名等，都可以通过枚举获得。功能强大的代价就是安全性的降低，完全绕过了面向对象的接口保护机制，使得代码流程变得复杂。此外，相比静态调用，它的运行效率会非常低。所以一般来说，反射只用在常规手段解决不了问题或者代价太大的地方。比如通过脚本调用原生代码，一般脚本会提供调用的方法名（字符串），而这个在代码编写时时完全无法确定究竟调用哪个方法的，通过反射就可以快速解决。<br>
　　　序列化是一种将对象保存到本地的机制，反序列化则是将本地数据恢复为运行时对象。比如通过网络传输给远程主机然后反序列化，或者关闭程序瑕疵启动后反序列化对象等。原理其实就是将对象的成员变量的值读取并保存下来（过程可能是递归的），具体实现可以有很多种，比如.Net的实现、Unity的实现，通过Json转化为字符串保存等实现方式。Unity中大量使用了序列化机制，比如通过Inspector窗口给脚本的变量赋值等，就是通过序列化来保存的。

>7..Net和Mono的关系？

作答：Mono是.Net的第三方实现和跨平台的替代方案。<br>
　　　.net framework是一套代码运行方案，它将托管语言编译为一种中间语言，称为MSIL（Microsoft Intermediate Language），并实现CLR（Common Language Runtime）来解析运行这种中间语言。这整套解决方案称为.net framework。可以看出来，它其实就是在操作系统之上又加了一层框架来运行代码，之所以这样设计，是为了上层代码能够跨平台运行（不同系统平台提供不同的.net底层实现，但是都对上层保持一致的接口，即可让上层代码运行在不同的平台）。<br>
　　　虽然.net天生就有跨平台的能力，但是由于微软的商业策略，.net在很长一段时间里只针对windows发布了底层支持。在这样的背景下，Mono项目应运而生。它实现了一套跨平台的.net框架，使得相同的代码可以运行在各个平台(由于版权保护，某些程序集没有实现，比如WindowsForm,WPF等)。<br>
　　　需要注意的是，由于Mono完全是按照自己的算法实现的，虽然整体与官方保持兼容，但是某些细微之处可能会有差异，比如语法解析等，可能会造成一些潜在的兼容性bug。

>8.C#函数Func(string a,string b)用Lambda表达式怎么写？

作答：（a,b）=> {};lambda无需声明参数类型和返回。详情可参考MSDN。[Lambda 表达式（C# 编程指南）](https://msdn.microsoft.com/zh-cn/library/bb397687.aspx)

>9.数列1,1,2,3,4,8,13...第n位数是多少？用C# for循环算法实现。

作答：

	public int ResultFunc(int n)
	{
		if(n <= 0) return 0;		//当n小于等于0时返回0，或报出异常
		int sum = 1;
		int s1 = 1, s2 = 2;
		for(int i = 2; i < n; i++)
		{
			sum = s1 + s2;
			s1 = s2;
			s2 = sum;
		}
		return sum;
	}

>10.请写一个快速排序，并阐述其工作原理。

作答：

	void FastSort(int[] array, int start, int end)
	{
		if(start >= end) return ;
		int low = start,high = end;
		int bs = array[low];
		while(low < high)
		{
			while(array[high] >= bs && high > low)
			{
				high --;
			}
			if(high > low)
			{
				array[low] = array[high];
				low++;
			}
			while(array[low] <= bs && low < high)
			{
				low ++;
			}
			if(low < high)
			{
				array[high] = array[low];
				high --;
			}
		}
		
	  	array[low] = bs;
		FastSort(array,start,low - 1);
		FastSort(array,high + 1,end);
	}

启动：FastSort(arry,0,array.Length - 1);<br>
快速排序的原理很简单：先选定集合中一个数，然后将大于它的数字都放在它的右侧，将小于它的数字都放在它的左侧。然后对它左侧和右侧的自己和重复这个过程，知道每个自己和只有一个元素为止。这就是分治法的思想，将大的问题分解为一个个小的问题来解决。<br>
而上面的代码正时对“选定集合中一个数，然后将大于它的数字都放在它的右侧，将小于它的数字都放在它的左侧”的一种实现，当然还可能有别的一些实现思路，只要能满足这个要求就可以。

>11.死锁的必要条件？怎么克服？

作答：死锁发生必须具备以下4个条件：<br>
　　1）互斥条件：一个资源每次只能被一个进程使用。<br>
　　2）请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>
　　3）不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。<br>
　　4）循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。<br>
　　通俗来讲，死锁指的是多个线程互相影响，导致都无法执行的情况。比如两个进程T1和T2同时执行，T1锁定了对象A1进行操作，T2锁定了对象A2进行操作，随后T1申请锁定A2，而T2申请锁定A1，这时候就发生了死锁，因为它们申请的锁定对象互相被对方锁定了，选入了怪圈。从这个场景中不难推出上面的4个条件，都是必须满足的。<br>
　　那么要解决死锁只需要在写代码时注意打破4个条件中的至少一个就好了。比如设计锁定对象可以同时被多个线程操作即可；锁定对象前先判断能否锁定；多线程访问多个对象按照统一的顺序；线程执行时一次性锁定所有要用到的对象等等。
>12.C#是否可以对内存直接进行操作？

作答：需要明确“内存”定义，指的是区别于文件等外存设备的内存操作，还是内存设备的读写操作。由于C#是托管语言，运行与CLR之上，因此是不能直接对内存设备进行操作的，但是可以通过P/Invoke等方式调用底层接口来操作。<br>
　　其次是程序自身的内存。整个内存大致可以分为两类：托管内存和非托管内存。对于C#默认的内存操作，一般是在托管内存上，比如通过MemoryStream等开辟内存空间，这类内存可以由运行时来管理，无需手动释放。<br>
 　　此外，通过Marshal等类型，可以对进程的非托管内存进行操作，这时候就要自己手动管理，不然会造成内存泄漏。